---
description: Untitled88 UI - Next.js Email Builder Application Rules
globs: ["**/*.tsx", "**/*.ts", "**/*.jsx", "**/*.js", "**/*.css"]
alwaysApply: true
---

# Untitled88 UI - Cursor Rules

## Project Overview
Untitled88 answers analytical questions and creates AI-driven dashboards built with Next.js 14 (Pages Router), TypeScript, Tailwind CSS, and NextAuth.js with Auth0.

## Critical Rules
- **NEVER create .md files** unless explicitly requested by the user
- Use Pages Router (NOT App Router) - this project uses the pages directory structure
- All API routes go in `src/pages/api/`
- Use functional components with hooks exclusively

## Tech Stack
- **Framework**: Next.js 16.1.1 (Pages Router)
- **Language**: TypeScript 5.7.3
- **React**: 19.2.1
- **Styling**: Tailwind CSS 3.3.3 + styled-components 6.1.19
- **State Management**: Zustand 5.0.8
- **Authentication**: NextAuth.js 4.23.1 + Auth0
- **UI Components**: Custom shadcn/ui inspired components
- **Charts**: Recharts 3.6.0, Chart.js 4.5.1
- **Drag & Drop**: react-dnd 16.0.1

## Project Structure
```
src/
├── components/
│   ├── ui/                    # Reusable UI components (button, card, input, badge, progress)
│   ├── dashboard/             # Dashboard-specific components
│   ├── email-blocks/          # Email block components
│   └── tools/                 # Tool components
├── pages/
│   ├── api/                   # API routes
│   │   └── auth/              # NextAuth.js Auth0 configuration
│   ├── _app.tsx               # App wrapper
│   ├── _document.tsx          # Document wrapper
│   ├── index.tsx              # Home page
│   ├── login.tsx              # Login page
│   └── dashboard.tsx          # Dashboard page
├── services/                  # API service layers
├── store/                     # Zustand stores
├── styles/                    # Global styles
├── utils/                     # Utility functions
└── types/                     # TypeScript type definitions
```

## Component Patterns

### React Components
- Use functional components with hooks exclusively
- Follow component composition over inheritance
- Use `React.memo` for expensive components when appropriate
- Implement proper error boundaries for component trees
- Keep components focused and single-responsibility

### Component File Structure
```typescript
import React from 'react';
import { ComponentProps } from './types';

export const ComponentName: React.FC<ComponentProps> = ({ prop1, prop2 }) => {
  // Hooks first
  const [state, setState] = React.useState();
  
  // Event handlers
  const handleClick = () => {};
  
  // Render
  return (
    <div>
      {/* Component content */}
    </div>
  );
};
```

## State Management

### Zustand Stores
- Use Zustand for global state management
- Keep state as close to components as possible
- Use React hooks for local component state
- Implement proper loading and error states

Example store pattern:
```typescript
import { create } from 'zustand';

interface StoreState {
  data: any;
  loading: boolean;
  error: string | null;
  fetchData: () => Promise<void>;
}

export const useStore = create<StoreState>((set) => ({
  data: null,
  loading: false,
  error: null,
  fetchData: async () => {
    set({ loading: true, error: null });
    try {
      // Fetch logic
      set({ data: result, loading: false });
    } catch (error) {
      set({ error: error.message, loading: false });
    }
  },
}));
```

## Authentication & API Integration

### Auth0 Configuration
- Use NextAuth.js with Auth0 provider
- All protected routes must check authentication status
- Use the secure API client for all backend calls
- Handle 401 errors with automatic session refresh

### API Client Pattern
```typescript
import { apiClient } from '@/utils/apiClient';

// The API client handles:
// - Automatic session refresh on 401
// - Retry logic with exponential backoff
// - HttpOnly cookie support
// - Graceful error handling

const response = await apiClient.get('/api/endpoint');
```

### Protected Pages
```typescript
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/router';

export default function ProtectedPage() {
  const { data: session, status } = useSession();
  const router = useRouter();

  React.useEffect(() => {
    if (status === 'unauthenticated') {
      router.push('/login');
    }
  }, [status, router]);

  if (status === 'loading') return <LoadingSpinner />;
  if (!session) return null;

  return <div>Protected content</div>;
}
```

## Styling Guidelines

### Tailwind CSS
- Use Tailwind utility classes as primary styling method
- Follow mobile-first responsive design approach
- Use custom theme configuration from `tailwind.config.js`
- Desktop-first design with mobile support

### styled-components
- Use for complex component styles that need props
- Keep styled components in the same file as the component
- Use TypeScript interfaces for styled component props

```typescript
import styled from 'styled-components';

const StyledButton = styled.button<{ variant?: 'primary' | 'secondary' }>`
  padding: 0.5rem 1rem;
  background: ${props => props.variant === 'primary' ? '#000' : '#fff'};
`;
```

## TypeScript Guidelines

### Type Definitions
- Define interfaces for all component props
- Use TypeScript strict mode
- Avoid `any` - use `unknown` or proper types
- Export types from dedicated `types/` files for reuse

```typescript
// Component props interface
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'ghost';
  size?: 'sm' | 'md' | 'lg';
  disabled?: boolean;
  onClick?: () => void;
  children: React.ReactNode;
}

// API response types
interface ApiResponse<T> {
  data: T;
  error?: string;
  success: boolean;
}
```

## Performance Optimization

### Code Splitting
- Use dynamic imports for heavy components
- Implement lazy loading with `next/dynamic`
- Use proper loading states during lazy loads

```typescript
import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(() => import('@/components/HeavyComponent'), {
  loading: () => <LoadingSpinner />,
  ssr: false,
});
```

### Image Optimization
- Always use `next/image` for images
- Provide proper width/height attributes
- Use appropriate image formats (WebP when possible)
- Implement lazy loading for images

```typescript
import Image from 'next/image';

<Image
  src="/logo.png"
  alt="Logo"
  width={200}
  height={100}
  priority={false} // true for above-the-fold images
/>
```

## SEO Best Practices

### Meta Tags
- Use the SEO component for consistent meta tags
- Implement proper Open Graph tags
- Include structured data where appropriate
- Use semantic HTML elements

```typescript
import SEO from '@/components/SEO';

<SEO
  title="Page Title | Untitled88"
  description="Page description"
  ogImage="/og-image.png"
/>
```

## Error Handling

### Component Error Boundaries
- Implement error boundaries for component trees
- Show user-friendly error messages
- Log errors for debugging

### API Error Handling
- Handle loading, success, and error states
- Provide user feedback for all states
- Implement retry logic for failed requests

```typescript
const [loading, setLoading] = useState(false);
const [error, setError] = useState<string | null>(null);

try {
  setLoading(true);
  setError(null);
  const result = await apiClient.post('/api/endpoint', data);
  // Handle success
} catch (err) {
  setError(err.message || 'An error occurred');
} finally {
  setLoading(false);
}
```

## Testing & Quality

### Code Quality
- Run `npm run lint` before committing
- Follow ESLint configuration
- Use Prettier for code formatting
- Type check with `npm run check-types`

## Environment Variables
- All public variables must be prefixed with `NEXT_PUBLIC_`
- Never commit `.env.local` file
- Document all environment variables in README

## Mobile Detection & Responsiveness
- Use the mobile detection utility from `utils/mobileDetection.ts`
- Implement responsive designs with Tailwind breakpoints
- Test on different screen sizes
- Support touch interactions

## Common Patterns

### Loading States
```typescript
{loading && <LoadingSpinner />}
{error && <ErrorDialog message={error} />}
{data && <Content data={data} />}
```

### Form Handling
```typescript
const [formData, setFormData] = useState({});

const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  setFormData({ ...formData, [e.target.name]: e.target.value });
};

const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  // Submit logic
};
```

## UI Component Library

### Available Components
- `Button` - Multi-variant with different sizes
- `Card` - Flexible with header, content, footer
- `Input` - Styled with focus states
- `Badge` - Status badges with variants
- `Progress` - Progress bar component
- `LoadingSpinner` - Animated loading indicator

Always use these components for consistency across the app.

## Best Practices Summary
1. **Never create .md files** unless explicitly requested
2. Use Pages Router, not App Router
3. Always use TypeScript with proper types
4. Implement proper loading and error states
5. Use the secure API client for all backend calls
6. Follow mobile-first responsive design
7. Optimize images with next/image
8. Implement proper SEO with meta tags
9. Keep components small and focused
10. Use Zustand for global state, hooks for local state
